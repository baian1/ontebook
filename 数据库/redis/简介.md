# redis

内存中的 nosql

1. 性能  
   将需要执行耗时久但是结果不频繁变动的 sql 的结果放在 redis 缓存
2. 并发  
   过多请求直接访问数据库,数据库会出现访问异常.使用 redis 做一个缓冲,减少对数据库的直接操作

## 快的原因

1. 纯内存操作
2. 单线程操作，避免了频繁的上下文切换
3. 采用了非阻塞 I/O 多路复用机制

## [数据类型](https://redis.io/topics/data-types)

1. String
2. List String 的列表,可以将数据插入/删除,在头部或尾部
3. Sets
4. Hashes
5. Sorted sets
6. Bitmaps and HyperLogLogs

## redis 的过期策略以及内存淘汰机制

采用定期删除+惰性删除:  
定期删除，redis 默认每个 100ms 随即抽取检查，是否有过期的 key,有过期 key 则删除.  
惰性删除,获取某个 Key 的时候,判断是否过期,过期就删除.

1. noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。
2. allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key。
3. allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key。
4. volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key。这种情况一般是把 redis 既当缓存，又做持久化存储的时候才用。
5. volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。
6. volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。

ps：如果没有设置 expire 的 key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。

> [分布式之 redis 复习精讲](https://www.cnblogs.com/rjzheng/p/9096228.html)

## 问题

1. 缓存和数据库双写一致性问题
2. 缓存雪崩问题
3. 缓存击穿问题
4. 缓存的并发竞争问题

### 双写一致性

### 缓存穿透和缓存雪崩

缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。

解决方案:

1. 利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试
2. 采用异步更新策略，无论 key 是否取到值，都直接返回。value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。
3. 提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的 key。迅速判断出，请求所携带的 Key 是否合法有效。如果不合法，则直接返回。

缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。

解决方案:

1. 给缓存的失效时间，加上一个随机值，避免集体失效。
2. 使用互斥锁，但是该方案吞吐量明显下降了。
3. 双缓存。我们有两个缓存，缓存 A 和缓存 B。缓存 A 的失效时间为 20 分钟，缓存 B 不设失效时间。自己做缓存预热操作。然后细分以下几个小点
   1. 从缓存 A 读数据库，有则直接返回
   2. A 没有数据，直接从 B 读数据，直接返回，并且异步启动一个更新线程。
   3. 更新线程同时更新缓存 A 和缓存 B。

### 并发竞争 key 问题

按照请求顺序,串行化
