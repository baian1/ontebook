# 原理

hooks 是使用了链表保存的

# useState

```
const [state, setState] = useState(initialState);
```

initialState 可以是值或者函数,只会在初次调用时加载  
state 保存值  
setState 用来改变值,类似 setState,传入参数

- 一个新的值替代老的 state
- 一个具有返回值的函数

默认值是简单的赋值,所以对象赋值就会是一个相同的对象,操作会对对象入参有影响  
可以通过第三个参数,初始化默认值函数,输入初始化参数返回初始值的函数，来解决

更新的时候如果单纯改变了对象的值,返回的对象地址没有改变,那么比较后 react 判断没有更新,就不会触发更新

# useReducer

# useEffect

# 出错记录

1. 问题发生:

   环境：在进度条的事件中,使用 isActive 表示进度条的触发状态

   问题：使用 useState 设置状态来控制事件动作,由于会依赖 state,每次的状态变更会导致事件刷新,最严重的是事件依赖的状态可能会是过时的状态,导致运行出错  
   比如 move 和 up 事件,如果我们使用 state,那么返回的将是两个行为固定的函数,每次 state 更新才会导致函数其行为变更,这样就导致了函数执行可能出错  
   在 up 之后设置 isActive 为 false,然后触发 react 更新,卸载函数,监听新函数(这里使用的事件是原生事件)  
   那么我们默认 move 事件将立刻不触发,可是由于 react 的更新机制问题,如果我们没有即使卸载函数,那么我们还可能触发老的 move 事件

   修改:
   使用 useRef 来记录状态
