# 解析器与解释器
扫描器负责分析词法，将源代码翻译成单词流  
解析器负责将单词流转换为语法树(syntax tree)或抽象语法树(abstract syntax tree)  

scannerless parsing 直接从源码生成语法树

编译器会将源码转换到另一种语言，比如js会转换到C++   
解释器是直接实现源码的语义,输入程序源码直接输出源码执行结果  

# 解释器
很多解释器内部是由 编译器+虚拟机 的方式完成，先通过编译器将源码转换为AST或者字节码，然后由虚拟机去完成实际的执行

## VM
VM既然被称为“机器”，一般认为输入是满足某种指令集架构（instruction set architecture，ISA）的指令序列，中间转换为目标ISA的指令序列并加以执行，输出为程序的执行结果的，就是VM。

VM需要采用某种方式输入语义，有几种选择：“编译”，例如微软的.NET中的CLR；“解释”，例如CPython、CRuby 1.9，许多老的JavaScript引擎等；也有介于两者之间的混合式，例如Sun的JVM，HotSpot。

编译和解释方式实现虚拟机最大的区别就在于是否存下目标代码：
- 编译的话会把输入的源程序以某种单位（例如基本块/函数/方法/trace等）翻译生成为目标代码，并存下来（无论是存在内存中还是磁盘上，无所谓），后续执行可以复用之；
- 解释的话则是把源程序中的指令逐条解释，不生成也不存下目标代码，后续执行没有多少可复用的信息。

## ISA
一个处理器支持的指令和指令的字节级编码就是这个处理器的ISA

## VM架构
如果直接模拟处理器，那处理器什么架构就只能用什么架构了  
但HLL VM的架构通常可以自由构造(翻译到C++或C)