# keyof
找到对象中的属性名
```
interface Person {
  name: string;
  age: number;
  location: string;
}

type K1 = keyof Person; // "name" | "age" | "location"
type K2 = keyof Person[];  // "length" | "push" | "pop" | "concat" | ...
                           // []表示是一个Person的数组对象
type K3 = keyof { [x: string]: Person };  // string
```
```
type P1 = Person["name"];  // string
type P2 = Person["name" | "age"];  // string | number
type P3 = string["charAt"];  // (pos: number) => string
type P4 = string[]["push"];  // (...items: string[]) => number
type P5 = string[][0];  // string
```

# extends
有条件类型，它能够表示非统一的类型。
有条件的类型会以一个条件表达式进行类型关系检测，从而在两种类型中选择其一。
```
T extends U ? X : Y
```
1. 首先，令T'和U'分别为T和U的实例，并将所有类型参数替换为any，如果T'不能赋值给U'，则将有条件的类型解析成Y。直观上讲，如果最宽泛的T的实例不能赋值给最宽泛的U的实例，那么我们就可以断定不存在可以赋值的实例，因此可以解析为Y。
2. 其次，针对每个在U内由推断声明引入的类型变量，依据从T推断到U来收集一组候选类型（使用与泛型函数类型推断相同的推断算法）。对于给定的推断类型变量V，如果有候选类型是从协变的位置上推断出来的，那么V的类型是那些候选类型的联合。反之，如果有候选类型是从逆变的位置上推断出来的，那么V的类型是那些候选类型的交叉类型。否则V的类型是never。
3. 然后，令T''为T的一个实例，所有推断的类型变量用上一步的推断结果替换，如果T''明显可赋值给U，那么将有条件的类型解析为X。除去不考虑类型变量的限制之外，明显可赋值的关系与正常的赋值关系一致。直观上，当一个类型明显可赋值给另一个类型，我们就能够知道它可以赋值给那些类型的所有实例。
4. 否则，这个条件依赖于一个或多个类型变量，有条件的类型解析被推迟进行。
## 分布式有条件类型
如果T的类型为A | B | C    
会解析为(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)  

## 用法
```
type Diff<T, U> = T extends U ? never : T;  // Remove types from T that are assignable to U
type Filter<T, U> = T extends U ? T : never;  // Remove types from T that are not assignable to U
type NonNullable<T> = Diff<T, null | undefined>;  // Remove null and undefined from T
```