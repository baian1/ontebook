# 元组类型
元组类型表示一个数组，其中元素的类型都是已知的，但是不一样是同样的类型。
```
// Declare a tuple type
var x: [string, number];
// 初始化
x = ['hello', 10]; // OK
// 错误的初始化
x = [10, 'hello']; // Error
```
对于超出一直索引元素不能赋值

## 固定长度元组
元组类型会考虑它的长度，不同长度的元组不再允许相互赋值。

# 联合类型
使用|表示
```
let a:string[]|string|(() => string);
```

# 映射类型
从一个类型创造新的类型
```
//原
interface Person {
  name: string;
  age: number;
  location: string;
}
//转换结果
interface PartialPerson {
  name?: string;
  age?: number;
  location?: string;
}
```

转换函数
```
type Partial<T> = {
    [P in keyof T]?: T[P];
};

type PartialPerson = Partial<Person>;
```

例子
```
// 保持类型相同，但每个属性是只读的。
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

// 相同的属性名称，但使值是一个Promise，而不是一个具体的值
type Deferred<T> = {
  [P in keyof T]: Promise<T[P]>;
};

// 为T的属性添加代理
type Proxify<T> = {
  [P in keyof T]: { get(): T[P]; set(v: T[P]): void }
};
```
# 泛型

## 泛型约束
```
//限制函数的参数必须可以满足string或者number的扩展
interface Test {
  a: string;
}

function test<T extends string | number | Test>(a: T) {
  return a;
}

test({ a: 'dsa', b: 1 })
```
## 泛型参数默认类型
```
//如果没有参数,那T就会是HTMLDivElement类型了
declare function create<T extends HTMLElement = HTMLDivElement, U = T[]>(element?: T, children?: U): Container<T, U>;
```
- 有默认类型的类型参数被认为是可选的。
- 必选的类型参数不能在可选的类型参数后。
- 如果类型参数有约束，类型参数的默认类型必须满足这个约束。
- 当指定类型实参时，你只需要指定必选类型参数的类型实参。 未指定的类型参数会被解析为它们的默认类型。
- 如果指定了默认类型，且类型推断无法选择一个候选类型，那么将使用默认类型作为推断结果。
- 一个被现有类或接口合并的类或者接口的声明可以为现有类型参数引入默认类型。
- 一个被现有类或接口合并的类或者接口的声明可以引入新的类型参数，只要它指定了默认类型。
## 增强的泛型推断
### 返回类型作为推断目标
可以从变量类型推断泛型
```
function arrayMap<T, U>(f: (x: T) => U): (a: T[]) => U[] {
    return a => a.map(f);
}

const lengths: (a: string[]) => number[] = arrayMap(s => s.length);
```
一个出错的例子
```
let x: Promise<string> = new Promise(resolve => {
  resolve(10);
  //Error!
});
```
### 从上下文类型中推断类型参数
```
let f: <T>(x: T) => T = y => y;
```
在使用的时候会对T进行类型推断
比如  
f(1)会在使用时推断y类型为number,设T为number,对函数进行类型判断
### 对泛型函数进行更严格的检查
```
type A = <T, U>(x: T, y: U) => [T, U];
type B = <S>(x: S, y: S) => [S, S];

function f(a: A, b: B) {
  a = b;  // Error
  b = a;  // Ok
}
```
## 函数
```
//没有输入T就默认是T为第一个参数的类型
//输入T按T来
function equal<T>(lhs: T, rhs: T): boolean {
  return lhs === rhs;
}
```

# 交叉类型
可以将两个对象混在一起  
```
interface T1 {
  a: boolean;
  b: string;
}

interface T2 {
  a: boolean;
  c: number;
}

type T = T1 & T2;

let a: T = {
  a: false,
  b: 'sad',
  c:1
}
```

# 缩小联合类型的范围
## 类型守护
JavaScript常用模式之一是在运行时使用typeof或instanceof检查表达式的类型。 在if语句里使用它们的时候，TypeScript可以识别出这些条件并且随之改变类型推断的结果。
## 标记联合类型
```
interface Square {
    kind: "square";
    size: number;
}

interface Rectangle {
    kind: "rectangle";
    width: number;
    height: number;
}

interface Circle {
    kind: "circle";
    radius: number;
}

type Shape = Square | Rectangle | Circle;

function area(s: Shape) {
    // 在下面的switch语句中，s的类型在每一个case中都被缩小
    // 根据判别属性的值，变量的其它属性不使用类型断言就可以被访问
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.width * s.height;
        case "circle": return Math.PI * s.radius * s.radius;
    }
}

function test1(s: Shape) {
    if (s.kind === "square") {
        s;  // Square
    }
    else {
        s;  // Rectangle | Circle
    }
}

function test2(s: Shape) {
    if (s.kind === "square" || s.kind === "rectangle") {
        return;
    }
    s;  // Circle
}
```
# 类型别名
通过type关键字给类型定一个别名
```
type PrimitiveArray = Array<string|number|boolean>;
type MyNumber = number;
```
# 弱类型探测
任何只包含了可选属性的类型被当作是“weak type”。  
给弱类型赋值时，如果这个值的属性与弱类型的属性没有任何重叠属性时会得到一个错误。
```
interface Options {
  data?: string;
  timeout?: number;
  maxRetries?: number;
}

function sendMessage(options: Options) {
  return options
}

const opts = {
  payload: "hello world!",
  retryOnFail: true,
}

// 错误!
sendMessage(opts);
```

# 显式赋值断言
```
//表示x一定会被初始化
let x!: number[];
initialize();
x.push(4);

function initialize() {
    x = [0, 1, 2, 3];
}
```